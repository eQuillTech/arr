// array slices (n) - P. Ahrenkiel

#include <cstdlib>
#include <math.h>
#include <iostream>

#import "arr1.hpp"
#import "arr2.hpp"

namespace arr {

template <class data_type>
arr2slice<data_type>::arr2slice(arr2<data_type>* a,
	const std::size_t iDim,
	const std::size_t iIndex)
{
	_a = a;
	if (iDim < 2)
		_iDim = iDim;
	else
		_iDim = 1;
	if (iIndex < _a->size(_iDim))
		_iIndex = iIndex;
	else
		_iIndex = _a->size(_iDim) - 1;
}

template <class data_type>
arr2slice<data_type>::arr2slice(const arr2slice<data_type>& A)
	: arr2slice(A._a,A._iDim,A._iIndex)
{}

template <class data_type>
arr2slice<data_type>::~arr2slice()
{
	// std::cout<<"-----------\n";
	// std::cout<<"destructing slice pointing to: "<<std::hex<<a->source();
	// std::cout<<", dim: "<<iDim;
	// std::cout<<", index: "<<iIndex<<"\n";
}

//
template <class data_type>
void arr2slice<data_type>::operator=(const arr2slice<data_type> A)
{
	if (_iDim != A.dim())
		return;
	std::size_t nA = size(), nB = size();
	std::size_t n = nA;
	if (n > nB)
		n = nB;
	for (std::size_t i = 0; i < n; ++i)
		at(i) = A(i);
}

//
template <class data_type>
void arr2slice<data_type>::operator=(const arr1<data_type>& A)
{
	if (size() != A.size())
	return;
	std::size_t n = size();
	for (std::size_t i = 0; i < n; i++)
	at(i) = A(i);
}

//
template <class data_type>
std::size_t arr2slice<data_type>::size() const
{
	return _a->size(1 - _iDim);
}

template <class data_type>
std::size_t arr2slice<data_type>::dim() const
{
	return _iDim;
}

template <class data_type>
std::size_t arr2slice<data_type>::index() const
{
	return _iIndex;
}
	
template <class data_type>
arr2<data_type>::arr2(const arr2slice<data_type>& A)
: arr2((A.dim() == 0) ? 1 : A.size(), (A.dim() == 1) ? 1 : A.size())
{
	std::size_t n = A.size();
	std::size_t i;
	switch (A.dim()) {
		case 0:
		for (i = 0; i < n; ++i)
			at(0, i) = A(i);
		break;
		
		case 1:
		for (i = 0; i < n; ++i)
			at(i, 0) = A(i);
		break;
	}
}

template <class data_type>
data_type &arr2slice<data_type>::at(const std::size_t i)
{
	return (_iDim==0) ? _a->at(_iIndex, i) : _a->at(i, _iIndex);
}

template <class data_type>
data_type const &arr2slice<data_type>::at(const std::size_t i) const
{
	return (_iDim==0) ? _a->at(_iIndex, i) : _a->at(i, _iIndex);
}

template <class data_type>
data_type &arr2slice<data_type>::operator()(const std::size_t i)
{
 return at(i);
}

template <class data_type>
data_type const &arr2slice<data_type>::operator()(const std::size_t i) const
{
 return at(i);
}

template <class data_type>
arr2<data_type> *arr2slice<data_type>::data()
{
	return _a;
}

template <class data_type>
arr2<data_type> const* arr2slice<data_type>::data() const
{
	return _a;
}

// friend
template <class data_type>
std::ostream& operator<<(std::ostream& os, const arr2slice<data_type>& A)
{
	os << (arr2<data_type>)(A);
	return os;
}
} // namespace arr
